{
  "hash": "1da2f8b7c2d0ecb8238cb9f90a5c0475",
  "result": {
    "engine": "knitr",
    "markdown": "# Manipuler les chaines de caractères\n\n**Objectifs du chapitre :**\n\n<div>\n\n```         \n*Apprendre à manipuler les chaines de caractères ainsi que les regex*\n\n</div>\n```\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#les librairies du chapître\nlibrary(tidyverse)\nlibrary(readr)\nlibrary(quanteda)\nlibrary(flextable)\ntheme_set(theme_minimal()) \n\nset_flextable_defaults(\n  font.size = 10, theme_fun = theme_vanilla,\n  padding = 6,\n  background.color = \"#EFEFEF\")\n\n\ndf <- read_csv(\"data/PMPLast3.csv\", \n    locale = locale(encoding = \"WINDOWS-1252\")) %>%\n  rename(Year=3, Text=11)\n```\n:::\n\n\n\n\n\n\n**Environnement de travail**\n\n\n## Stringr\n\n`[stringr](https://stringr.tidyverse.org/index.html)` est le package de la suite tidyverse destiné à manipuler les chaînes de caractère.\n\n### Compter \n\nDans le code suivant on utilise le set de donnée PMP40ans. Le but est de compter le nombre de fois où un terme apparaît dans chacun des textes avec la fonction `str_count`. On en donne l'évolution au cours du temps\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- df %>% \n  dplyr::select(Year, Text)%>% \n  filter(!is.na(Text))%>% #on filtre les textes manquants\n  mutate(n=str_count(Text, \"évaluation\")) %>% #\n  group_by(Year)%>% #on agrège sur l'année \n  summarise(n=sum(n))\n\nggplot(foo, aes(Year,n))+geom_line() +\n  geom_smooth()+\n  ylim(0,40)\n```\n\n::: {.cell-output-display}\n![](q05_manipuler_caractere_files/figure-html/501-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n### Extraire, supprimer et remplacer\n\nDans certaines situations on peut souhaiter extraire une chaîne de caractère pour l'utiliser à un autre usage.L'exemple ordinaire est celui d'extraire l'année d'une date ou un auteur d'un titre.\n\n`str_extract`\n\n\n`str_replace`\n\n\n### Majuscules, minuscule et espaces.\n\n\n## Regex\n\nDans la section précédente on a appris à rechercher une chaîne de caractères, ou plusieurs dans une chaîne de caractères, à les compter, les extraire, les enlever, les remplacer. Dans nos exemples, on a employé des pattern simple. Dans l'exemple \"évaluation\", on a tenu compte uniquement de cette forme, elle aurait pu être au pluriel, porté une majuscule, exacte ou inexacte. L'enjeu est de pouvoir saisir toute les variantes en une seule expression.\n\nDans notre exemple la solution est la suivante : `[E|e|é]valuation.*`, en voulant saisir plus de variation on peut employer `[E|e|é]valu.*` qui permet se saisir les former verbales.\n\nUne expression régulière, ou regex, ou expression rationnelle ou expression normale ou motif est une chaîne de caractères qui décrit, selon une syntaxe précise, un ensemble de chaînes de caractères possibles. Son invention est attribuée au logicien [Stephen Cole Kleene](https://fr.wikipedia.org/wiki/Stephen_Cole_Kleene))\n\nsa pratique se fonde sur une forte théorie.\n\n### les éléments principaux\n\nhttps://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432\n\nLes regex reposent sur plusieurs concepts :\n\n-   des jeux de caractères qui sont défini par des crochets \\[\\]. Dans l'exemple suivant on remplace toutes les voyelles, par rien, puis toute les majuscules par X. Il y a différentes variantes par exemple \\[A-Z\\] pour les majuscules ou \\[0-9\\] pour les chiffres.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mathias Malzieu\nx<-c(\"Si Cendrillon avait eu une horloge dans le coeur, elle aurait bloqué les aiguilles à minuit moins une et se serait éclaté au bal toute sa vie.\")\n\nstr_replace_all(x,\"[aeiou]\", \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S Cndrlln vt  n hrlg dns l cr, ll rt blqé ls glls à mnt mns n t s srt éclté  bl tt s v.\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_replace_all(x,\"[A-Z]\", \"X\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Xi Xendrillon avait eu une horloge dans le coeur, elle aurait bloqué les aiguilles à minuit moins une et se serait éclaté au bal toute sa vie.\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   Les méta caractères représentent un type de caractère. Ils commencent généralement par une barre oblique inverse (backslash). La barre oblique inverse étant un caractère spécial dans R, elle doit être échappée chaque fois qu'elle est utilisée avec une autre barre oblique inverse. En d'autres termes, R exige deux barres obliques inverses lors de l'utilisation de méta caractères. Chaque méta-caractère correspondra à un seul caractère.\n\n`\\\\s` : Ce méta caractère représente les espaces. Il correspondra à chaque espace, tabulation et nouvelle ligne.\n\n-   Les quantificateurs permette de contrôler le nombre de caractère que l'on attend. Par exemple , le quantificateur + indique que l'on souhaite que l'élément recherché apparaisse une ou plus fois. Si l'action est d'identifier a, a+, renvoie a, aa, aaa etc . Ceci ne semble pas très utile, sauf si le caractère peut être n'importe quelle lettre de l'alphabet, ce qui est représenté par le . Une variante du + est \\*, c'est la même idée mais cela inclue l'option de 0 caractère.\n\n-   Groupes de capture\n\n### Des formules usuelles\n\nLa formulation de regex est un art, dans le quotidien on se contentera de reprendre des formules communes et d'utiliser des générateurs de regex comme xxxx\n\nen voici quelles-unes\n\n-   date `\\[0-9\\]{2}-\\[0-9\\]{2}-\\[0-9\\]{2}\"`\n\n-   mention\n\n-   adresse web\n\n-   numéro de téléphone\n\n## Conclusion\n\nSur le plan pratique nous avons fortement avancé, nous pouvons jouer avec les chaînes de caractère, et en saisir les variations. nous avons les moyens de pré-traiter le texte\n\n-   pour réduire les morphologies\n-   pour extraire des entités nommées\n-   ...\n",
    "supporting": [
      "q05_manipuler_caractere_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}